{"id":589003598,"lang":"java","time":"1Â month","timestamp":1637222497,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/589003598/","is_pending":"Not Pending","title":"Count of Smaller Numbers After Self","memory":"N/A","code":"class Solution {\n    \n    public static class SegmentTreeNode {\n\n        public int start;\n        public int end;\n        public int sum;\n\n        public SegmentTreeNode left;\n        public SegmentTreeNode right;\n\n        public SegmentTreeNode(int start, int end) {\n            this.start = start;\n            this.end = end;\n            sum = 0;\n        }\n\n    }\n\n    public SegmentTreeNode buildTree(int start, int end) {\n        if (start > end) {\n            return null;\n        }\n\n        SegmentTreeNode node = new SegmentTreeNode(start, end);\n        if (start == end) {\n            return node;\n        }\n        int mid = start + (end - start) / 2;\n        node.left = buildTree(start, mid);\n        node.right = buildTree(mid + 1, end);\n        return node;\n    }\n\n    public void update(SegmentTreeNode node, int index) {\n        if (node == null) {\n            return;\n        }\n\n        if (node.start == index && node.end == index) {\n            node.sum += 1;\n            return;\n        }\n\n        int mid = (node.start + node.end) / 2;\n        if (index <= mid) {\n            update(node.left, index);\n        } else {\n            update(node.right, index);\n        }\n\n        node.sum = node.left.sum + node.right.sum;\n    }\n\n    public int sumRange(SegmentTreeNode root, int start, int end) {\n        if (root == null || start > end) {\n            return 0;\n        }\n\n        if (root.start == start && root.end == end) {\n            return root.sum;\n        }\n        int mid = root.start + (root.end - root.start) / 2;\n        if (end <= mid) {\n            return sumRange(root.left, start, end);\n        } else if (start > mid) {\n            return sumRange(root.right, start, end);\n        }\n\n        return sumRange(root.left, start, mid) + sumRange(root.right, mid + 1, end);\n    }\n\n    public List<Integer> countSmaller(int[] arr) {\n        List<Integer> res = new ArrayList<>();\n        if (arr == null || arr.length == 0) return new ArrayList<>();\n\n        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n\n        for (int e : arr) {\n            min = Math.min(min, e);\n            max = Math.max(max, e);\n        }\n\n        SegmentTreeNode node = buildTree(min, max);\n        for (int i = arr.length - 1; i >= 0; i--) {\n            update(node, arr[i]);\n            int sum = sumRange(node, min, arr[i] - 1);\n            res.add(sum);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}","compare_result":"11100000000000000000000000000000000000000000000000000000000000000","title_slug":"count-of-smaller-numbers-after-self"}