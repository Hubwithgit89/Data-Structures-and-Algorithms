{"id":589008576,"lang":"java","time":"1Â month","timestamp":1637223332,"status_display":"Accepted","runtime":"144 ms","url":"/submissions/detail/589008576/","is_pending":"Not Pending","title":"Count of Smaller Numbers After Self","memory":"56.9 MB","code":"class Solution {\n    \n    public class SegmentTreeNode {\n        public SegmentTreeNode left;\n        public SegmentTreeNode right;\n\n        public int Start;\n        public int End;\n        public int Sum;\n\n        public SegmentTreeNode(int start, int end) {\n            Start = start;\n            End = end;\n            Sum = 0;\n        }\n\n\n    }\n\n    public SegmentTreeNode buildTree(int start, int end) {\n        if (start > end) {\n            return null;\n        }\n\n        SegmentTreeNode node = new SegmentTreeNode(start, end);\n\n        if (start == end) {\n            return node;\n        }\n\n        int mid = start + (end - start) / 2;\n        node.left = buildTree(start, mid);\n        node.right = buildTree(mid + 1, end);\n\n        return node;\n    }\n\n    public void update(SegmentTreeNode node, int index) {\n        if (node == null) {\n            return;\n        }\n        if (node.Start == index && node.End == index) {\n            node.Sum += 1;\n            return;\n        }\n        int mid = node.Start + (node.End - node.Start) / 2;\n        if (index <= mid) {\n            update(node.left, index);\n        }\n        else {\n            update(node.right, index);\n        }\n        node.Sum = node.left.Sum + node.right.Sum;\n    }\n\n    public int SumRange(SegmentTreeNode root, int start, int end) {\n        if (root == null || start >end) {\n            return 0;\n        }\n\n        if (root.Start == start && root.End == end) {\n            return root.Sum;\n        }\n        int mid = root.Start + (root.End - root.Start) / 2;\n        if (end <= mid) {\n            return SumRange(root.left, start, end);\n        }\n        else if (start > mid) {\n            return SumRange(root.right, start, end);\n        }\n        return SumRange(root.left, start, mid) + SumRange(root.right, mid + 1, end);\n    }\n\n\n    public List<Integer> countSmaller(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return new ArrayList<>();\n        }\n        int[] counts = new int[nums.length];\n        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n\n        for (int el : nums) {\n            min = Math.min(min, el);\n            max = Math.max(max, el);\n        }\n\n        SegmentTreeNode root = buildTree(min, max);\n\n        for (int i = nums.length - 1; i >= 0; i--) {\n            update(root, nums[i]);\n            counts[i] = SumRange(root, min, nums[i] - 1);\n        }\n\n\n        List<Integer> ans = new ArrayList<>();\n        for (int i : counts) {\n            ans.add(i);\n        }\n        return ans;\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111","title_slug":"count-of-smaller-numbers-after-self"}